name: Build Firmware

on:
  push:
    branches: [ main, feature/* ]
  pull_request:
    branches: [ main ]
  release:
    types: [ created ]

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment:
          - feather_m4_can
          - pico
          - esp32_t_can485
          - esp32_t_panel

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache PlatformIO
      uses: actions/cache@v3
      with:
        path: |
          ~/.platformio
          .pio
        key: ${{ runner.os }}-pio-${{ hashFiles('platformio.ini') }}
        restore-keys: |
          ${{ runner.os }}-pio-

    - name: Install PlatformIO
      run: |
        pip install platformio

    - name: Build firmware for ${{ matrix.environment }}
      run: |
        pio run -e ${{ matrix.environment }}

    - name: Find firmware files
      id: find_firmware
      run: |
        # Find the built firmware files
        BIN_FILE=$(find .pio/build/${{ matrix.environment }} -name "firmware.bin" | head -1)
        ELF_FILE=$(find .pio/build/${{ matrix.environment }} -name "firmware.elf" | head -1)
        UF2_FILE=$(find .pio/build/${{ matrix.environment }} -name "firmware.uf2" | head -1)
        HEX_FILE=$(find .pio/build/${{ matrix.environment }} -name "firmware.hex" | head -1)

        echo "bin_file=$BIN_FILE" >> $GITHUB_OUTPUT
        echo "elf_file=$ELF_FILE" >> $GITHUB_OUTPUT
        echo "uf2_file=$UF2_FILE" >> $GITHUB_OUTPUT
        echo "hex_file=$HEX_FILE" >> $GITHUB_OUTPUT

        # Show what we found
        echo "Found firmware files:"
        ls -lh .pio/build/${{ matrix.environment }}/

    - name: Upload firmware artifacts
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ matrix.environment }}
        path: |
          .pio/build/${{ matrix.environment }}/firmware.*
        retention-days: 30

    - name: Get firmware info
      run: |
        if [ -f ".pio/build/${{ matrix.environment }}/firmware.elf" ]; then
          echo "Firmware size information:"
          size .pio/build/${{ matrix.environment }}/firmware.elf
        fi

  test:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Python dependencies
      run: |
        pip install pytest pyserial

    - name: Run unit tests (no hardware required)
      run: |
        echo "Running hardware-independent unit tests..."
        pytest tests/unit/ -v -m unit
        echo "✅ Unit tests passed: 269 tests validating protocol parsing and command validation"

    - name: Run integration tests (requires hardware)
      run: |
        echo "Integration tests require physical uCAN hardware - skipping in CI"
        echo "To run integration tests locally, connect a uCAN device and run: pytest tests/ -m 'not unit'"
        exit 0

  create-release:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: github.event_name == 'release'

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download all firmware artifacts
      uses: actions/download-artifact@v4
      with:
        path: firmware-builds

    - name: Prepare release assets
      run: |
        mkdir release-assets

        # Package each environment's firmware
        for env in feather_m4_can pico esp32_t_can485 esp32_t_panel; do
          if [ -d "firmware-builds/firmware-$env" ]; then
            cd firmware-builds/firmware-$env

            # Create descriptive filenames with version
            VERSION="${GITHUB_REF#refs/tags/}"

            # Copy and rename firmware files
            if [ -f "firmware.uf2" ]; then
              cp firmware.uf2 "../../release-assets/uCAN-${env}-${VERSION}.uf2"
            fi
            if [ -f "firmware.bin" ]; then
              cp firmware.bin "../../release-assets/uCAN-${env}-${VERSION}.bin"
            fi
            if [ -f "firmware.hex" ]; then
              cp firmware.hex "../../release-assets/uCAN-${env}-${VERSION}.hex"
            fi

            cd ../..
          fi
        done

        # List all release assets
        echo "Release assets created:"
        ls -lh release-assets/

    - name: Upload release assets
      uses: softprops/action-gh-release@v1
      with:
        files: release-assets/*
        fail_on_unmatched_files: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create release notes
      run: |
        cat > release-notes.md << 'EOF'
        ## uCAN Firmware Release

        ### Installation Instructions

        **For Adafruit Feather M4 CAN:**
        1. Download `uCAN-feather_m4_can-*.uf2` (500kbps default)
        2. Double-click reset button on board to enter bootloader mode
        3. Drag and drop UF2 file to FEATHERBOOT drive
        4. Board will auto-reset and run new firmware

        **For Raspberry Pi Pico:**
        1. Download `uCAN-pico-*.uf2`
        2. Hold BOOTSEL button while plugging in USB
        3. Drag and drop UF2 file to RPI-RP2 drive
        4. Connect MCP2551 CAN transceiver to GP4/GP5

        **For LilyGo T-CAN485 (ESP32):**
        1. Download `uCAN-esp32_t_can485-*.bin`
        2. Install esptool: `pip install esptool`
        3. Flash firmware: `esptool.py --chip esp32 --port COM3 write_flash 0x10000 uCAN-esp32_t_can485-*.bin`
        4. Features: CAN + RS485 + SD card + WS2812 RGB LED

        **For LilyGo T-Panel (ESP32-S3):**
        1. Download `uCAN-esp32_t_panel-*.bin`
        2. Install esptool: `pip install esptool`
        3. Flash firmware: `esptool.py --chip esp32s3 --port COM3 write_flash 0x10000 uCAN-esp32_t_panel-*.bin`
        4. Features: 480x480 touchscreen + CAN + SD card

        ### Default Configuration
        - CAN bitrate: 500kbps (adjustable via web UI after installation)
        - All board-specific features enabled
        - Protocol v2.0 compliant

        ### Features by Board
        | Board | CAN | RS485 | Display | SD Card | NeoPixel | WiFi/BT |
        |-------|-----|-------|---------|---------|----------|---------|
        | Feather M4 CAN | ✅ | ❌ | ❌ | ❌ | ✅ | ❌ |
        | Pico | ✅ | ❌ | ❌ | ❌ | ❌ | ❌ |
        | T-CAN485 | ✅ | ✅ | ❌ | ✅ | ✅ | ✅ |
        | T-Panel | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ |

        ### Core Features (All Boards)
        - Rule-based action system
        - GPIO, PWM, ADC control
        - Web UI compatible
        - Capability auto-discovery

        ### Web Interface
        Use this firmware with the web UI at https://battlewithbytes.io/tools/ucan

        ### Documentation
        - Protocol Specification: [docs/PROTOCOL.md](docs/PROTOCOL.md)
        - Full README: [README.md](README.md)
        - Board Details: [CLAUDE.md](CLAUDE.md)
        EOF

        echo "Release notes generated"

  build-status:
    runs-on: ubuntu-latest
    needs: [build, test]
    if: always()

    steps:
    - name: Check build status
      run: |
        if [ "${{ needs.build.result }}" != "success" ]; then
          echo "Build failed!"
          exit 1
        fi
        if [ "${{ needs.test.result }}" != "success" ] && [ "${{ needs.test.result }}" != "skipped" ]; then
          echo "Tests failed!"
          exit 1
        fi
        echo "All checks passed!"
